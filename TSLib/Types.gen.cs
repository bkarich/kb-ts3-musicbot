// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />








#nullable enable
using Newtonsoft.Json;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;

namespace TSLib
{
	public static class TsTypes
	{
		public static Type[] All => new Type[] { typeof(Uid),typeof(ClientDbId),typeof(ClientId),typeof(ChannelId),typeof(ServerGroupId),typeof(ChannelGroupId), };
	}

	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(Uid.Converter))]
	public readonly partial struct Uid : IEquatable<Uid>
	{
		public static readonly Uid Null = new Uid(string.Empty);
		public static Uid To(String v) => new Uid(v);

		public String Value { get; }
		public Uid(String value) { if (value == null) throw new ArgumentNullException(nameof(value)); Value = value; }
		public static explicit operator Uid(String v) => new Uid(v);
		public static bool operator ==(Uid a, Uid b) => a.Value == b.Value;
		public static bool operator !=(Uid a, Uid b) => a.Value != b.Value;
		public override int GetHashCode() => Value?.GetHashCode() ?? 0 ;
		public override bool Equals(object? obj) => obj is Uid c && this.Equals(c);
		public override string ToString() => Value ?? "";
		
		public bool Equals(Uid other) => string.Equals(Value, other.Value, StringComparison.Ordinal);
		
		public static Uid? TryFrom(object value) {
			
			if (value is string s) return new Uid(s);
			return null;
			
			
		}

		private class Converter : JsonConverter<Uid>
		{
			public override void WriteJson(JsonWriter writer, Uid value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override Uid ReadJson(JsonReader reader, Type objectType, Uid existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new Uid((reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ClientDbId.Converter))]
	public readonly partial struct ClientDbId : IFormattable, IEquatable<ClientDbId>
	{
		public static readonly ClientDbId Null = new ClientDbId(default);
		public static ClientDbId To(UInt64 v) => new ClientDbId(v);

		public UInt64 Value { get; }
		public ClientDbId(UInt64 value) {  Value = value; }
		public static explicit operator ClientDbId(UInt64 v) => new ClientDbId(v);
		public static bool operator ==(ClientDbId a, ClientDbId b) => a.Value == b.Value;
		public static bool operator !=(ClientDbId a, ClientDbId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ClientDbId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ClientDbId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ClientDbId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ClientDbId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ClientDbId(num);
			if (value is IConvertible c) return new ClientDbId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
			
		}

		private class Converter : JsonConverter<ClientDbId>
		{
			public override void WriteJson(JsonWriter writer, ClientDbId value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override ClientDbId ReadJson(JsonReader reader, Type objectType, ClientDbId existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new ClientDbId(UInt64.Parse(reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ClientId.Converter))]
	public readonly partial struct ClientId : IFormattable, IEquatable<ClientId>
	{
		public static readonly ClientId Null = new ClientId(default);
		public static ClientId To(UInt16 v) => new ClientId(v);

		public UInt16 Value { get; }
		public ClientId(UInt16 value) {  Value = value; }
		public static explicit operator ClientId(UInt16 v) => new ClientId(v);
		public static bool operator ==(ClientId a, ClientId b) => a.Value == b.Value;
		public static bool operator !=(ClientId a, ClientId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ClientId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ClientId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ClientId? TryFrom(object value) {
			
			if (value is UInt16 bvalue) return new ClientId(bvalue);
			if (value is string s && UInt16.TryParse(s, out var num)) return new ClientId(num);
			if (value is IConvertible c) return new ClientId(c.ToUInt16(CultureInfo.InvariantCulture));

			return null;
			
			
		}

		private class Converter : JsonConverter<ClientId>
		{
			public override void WriteJson(JsonWriter writer, ClientId value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override ClientId ReadJson(JsonReader reader, Type objectType, ClientId existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new ClientId(UInt16.Parse(reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ChannelId.Converter))]
	public readonly partial struct ChannelId : IFormattable, IEquatable<ChannelId>
	{
		public static readonly ChannelId Null = new ChannelId(default);
		public static ChannelId To(UInt64 v) => new ChannelId(v);

		public UInt64 Value { get; }
		public ChannelId(UInt64 value) {  Value = value; }
		public static explicit operator ChannelId(UInt64 v) => new ChannelId(v);
		public static bool operator ==(ChannelId a, ChannelId b) => a.Value == b.Value;
		public static bool operator !=(ChannelId a, ChannelId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ChannelId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ChannelId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ChannelId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ChannelId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ChannelId(num);
			if (value is IConvertible c) return new ChannelId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
			
		}

		private class Converter : JsonConverter<ChannelId>
		{
			public override void WriteJson(JsonWriter writer, ChannelId value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override ChannelId ReadJson(JsonReader reader, Type objectType, ChannelId existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new ChannelId(UInt64.Parse(reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ServerGroupId.Converter))]
	public readonly partial struct ServerGroupId : IFormattable, IEquatable<ServerGroupId>
	{
		public static readonly ServerGroupId Null = new ServerGroupId(default);
		public static ServerGroupId To(UInt64 v) => new ServerGroupId(v);

		public UInt64 Value { get; }
		public ServerGroupId(UInt64 value) {  Value = value; }
		public static explicit operator ServerGroupId(UInt64 v) => new ServerGroupId(v);
		public static bool operator ==(ServerGroupId a, ServerGroupId b) => a.Value == b.Value;
		public static bool operator !=(ServerGroupId a, ServerGroupId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ServerGroupId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ServerGroupId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ServerGroupId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ServerGroupId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ServerGroupId(num);
			if (value is IConvertible c) return new ServerGroupId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
			
		}

		private class Converter : JsonConverter<ServerGroupId>
		{
			public override void WriteJson(JsonWriter writer, ServerGroupId value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override ServerGroupId ReadJson(JsonReader reader, Type objectType, ServerGroupId existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new ServerGroupId(UInt64.Parse(reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ChannelGroupId.Converter))]
	public readonly partial struct ChannelGroupId : IFormattable, IEquatable<ChannelGroupId>
	{
		public static readonly ChannelGroupId Null = new ChannelGroupId(default);
		public static ChannelGroupId To(UInt64 v) => new ChannelGroupId(v);

		public UInt64 Value { get; }
		public ChannelGroupId(UInt64 value) {  Value = value; }
		public static explicit operator ChannelGroupId(UInt64 v) => new ChannelGroupId(v);
		public static bool operator ==(ChannelGroupId a, ChannelGroupId b) => a.Value == b.Value;
		public static bool operator !=(ChannelGroupId a, ChannelGroupId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ChannelGroupId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ChannelGroupId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ChannelGroupId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ChannelGroupId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ChannelGroupId(num);
			if (value is IConvertible c) return new ChannelGroupId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
			
		}

		private class Converter : JsonConverter<ChannelGroupId>
		{
			public override void WriteJson(JsonWriter writer, ChannelGroupId value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override ChannelGroupId ReadJson(JsonReader reader, Type objectType, ChannelGroupId existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new ChannelGroupId(UInt64.Parse(reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	
}